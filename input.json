{"mode": "sequential", "prompts": ["Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n\n\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n\nConstraints:\n\n    nums1.length == m\n    nums2.length == n\n    0 <= m <= 1000\n    0 <= n <= 1000\n    1 <= m + n <= 2000\n    -106 <= nums1[i], nums2[i] <= 106\n\nfrom typing import List\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n", "Given the head of a linked list, return the list after sorting it in ascending order.\n\n\n\nExample 1:\n\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n\nExample 2:\n\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n\nExample 3:\n\nInput: head = []\nOutput: []\n\n\n\nConstraints:\n\n    The number of nodes in the list is in the range [0, 5 * 104].\n    -105 <= Node.val <= 105\n\n# Definition for singly-linked list.\nfrom typing import Optional\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n", "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\n\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\n\n\n\nExample 1:\n\nInput: g = [1,2,3], s = [1,1]\nOutput: 1\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.\nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\nExample 2:\n\nInput: g = [1,2], s = [1,2,3]\nOutput: 2\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.\nYou have 3 cookies and their sizes are big enough to gratify all of the children,\nYou need to output 2.\n\n\n\nConstraints:\n\n    1 <= g.length <= 3 * 104\n    0 <= s.length <= 3 * 104\n    1 <= g[i], s[j] <= 231 - 1\n\nfrom typing import List\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n\n", "Give me an energy-optimized solution for this problem,\n\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n\n\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n\nConstraints:\n\n    nums1.length == m\n    nums2.length == n\n    0 <= m <= 1000\n    0 <= n <= 1000\n    1 <= m + n <= 2000\n    -106 <= nums1[i], nums2[i] <= 106\n\nfrom typing import List\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n", "Give me an energy-optimized solution for this problem,\n\nGiven the head of a linked list, return the list after sorting it in ascending order.\n\n\n\nExample 1:\n\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n\nExample 2:\n\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n\nExample 3:\n\nInput: head = []\nOutput: []\n\n\n\nConstraints:\n\n    The number of nodes in the list is in the range [0, 5 * 104].\n    -105 <= Node.val <= 105\n\n# Definition for singly-linked list.\nfrom typing import Optional\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n", "Give me an energy-optimized solution for this problem,\n\nAssume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\n\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\n\n\n\nExample 1:\n\nInput: g = [1,2,3], s = [1,1]\nOutput: 1\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.\nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\nExample 2:\n\nInput: g = [1,2], s = [1,2,3]\nOutput: 2\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.\nYou have 3 cookies and their sizes are big enough to gratify all of the children,\nYou need to output 2.\n\n\n\nConstraints:\n\n    1 <= g.length <= 3 * 104\n    0 <= s.length <= 3 * 104\n    1 <= g[i], s[j] <= 231 - 1\n\nfrom typing import List\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n\n", "Use library functions in the following problem,\n\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n\n\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n\nConstraints:\n\n    nums1.length == m\n    nums2.length == n\n    0 <= m <= 1000\n    0 <= n <= 1000\n    1 <= m + n <= 2000\n    -106 <= nums1[i], nums2[i] <= 106\n\nfrom typing import List\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n", "Use library functions in the following problem,\n\nGiven the head of a linked list, return the list after sorting it in ascending order.\n\n\n\nExample 1:\n\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n\nExample 2:\n\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n\nExample 3:\n\nInput: head = []\nOutput: []\n\n\n\nConstraints:\n\n    The number of nodes in the list is in the range [0, 5 * 104].\n    -105 <= Node.val <= 105\n\n# Definition for singly-linked list.\nfrom typing import Optional\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n", "Use library functions in the following problem,\n\nAssume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\n\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\n\n\n\nExample 1:\n\nInput: g = [1,2,3], s = [1,1]\nOutput: 1\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.\nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\nExample 2:\n\nInput: g = [1,2], s = [1,2,3]\nOutput: 2\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.\nYou have 3 cookies and their sizes are big enough to gratify all of the children,\nYou need to output 2.\n\n\n\nConstraints:\n\n    1 <= g.length <= 3 * 104\n    0 <= s.length <= 3 * 104\n    1 <= g[i], s[j] <= 231 - 1\n\nfrom typing import List\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n\n", "Use a for loop instead of a while loop in the following problem,\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n\n\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n\nConstraints:\n\n    nums1.length == m\n    nums2.length == n\n    0 <= m <= 1000\n    0 <= n <= 1000\n    1 <= m + n <= 2000\n    -106 <= nums1[i], nums2[i] <= 106\n\nfrom typing import List\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n", "Use a for loop instead of a while loop in the following problem,\nGiven the head of a linked list, return the list after sorting it in ascending order.\n\n\n\nExample 1:\n\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n\nExample 2:\n\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n\nExample 3:\n\nInput: head = []\nOutput: []\n\n\n\nConstraints:\n\n    The number of nodes in the list is in the range [0, 5 * 104].\n    -105 <= Node.val <= 105\n\n# Definition for singly-linked list.\nfrom typing import Optional\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n", "Use a for loop instead of a while loop in the following problem,\nAssume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\n\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\n\n\n\nExample 1:\n\nInput: g = [1,2,3], s = [1,1]\nOutput: 1\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.\nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\nExample 2:\n\nInput: g = [1,2], s = [1,2,3]\nOutput: 2\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.\nYou have 3 cookies and their sizes are big enough to gratify all of the children,\nYou need to output 2.\n\n\n\nConstraints:\n\n    1 <= g.length <= 3 * 104\n    0 <= s.length <= 3 * 104\n    1 <= g[i], s[j] <= 231 - 1\n\nfrom typing import List\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n\n"], "prompt_labels": ["Median_of_Two_Sorted_Arrays", "Sort_List", "Assign_Cookies", "Median_of_Two_Sorted_Arrays_energy", "Sort_List_energy", "Assign_Cookies_energy", "Median_of_Two_Sorted_Arrays_library_functions", "Sort_List_library_functions", "Assign_Cookies_library_functions", "Median_of_Two_Sorted_Arrays_for_loop", "Sort_List_for_loop", "Assign_Cookies_for_loop"]}